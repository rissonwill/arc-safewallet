/**
 * Solidity Compiler Service
 * Uses solc-js for compiling Solidity contracts
 */

// Compilation result interface
export interface CompilationResult {
  success: boolean;
  contracts?: {
    [contractName: string]: {
      abi: any[];
      bytecode: string;
      deployedBytecode: string;
      gasEstimates?: {
        creation: { codeDepositCost: string; executionCost: string; totalCost: string };
        external: { [method: string]: string };
      };
    };
  };
  errors?: Array<{
    severity: "error" | "warning";
    message: string;
    formattedMessage: string;
    sourceLocation?: {
      file: string;
      start: number;
      end: number;
    };
  }>;
  warnings?: string[];
}

// Generate TypeScript interface from ABI
export function generateTypeScriptInterface(
  contractName: string,
  abi: any[]
): string {
  const lines: string[] = [];
  
  lines.push(`// Auto-generated TypeScript interface for ${contractName}`);
  lines.push(`// Generated by Arc SafeWallet Compiler`);
  lines.push("");
  lines.push(`import { ethers } from 'ethers';`);
  lines.push("");
  
  // Generate type definitions for structs/tuples
  const structTypes: string[] = [];
  
  // Generate function signatures
  const functionSignatures: string[] = [];
  const eventSignatures: string[] = [];
  
  for (const item of abi) {
    if (item.type === "function") {
      const inputs = item.inputs
        .map((input: any) => `${input.name}: ${solidityToTsType(input.type)}`)
        .join(", ");
      
      const outputs = item.outputs?.length > 0
        ? item.outputs.length === 1
          ? solidityToTsType(item.outputs[0].type)
          : `[${item.outputs.map((o: any) => solidityToTsType(o.type)).join(", ")}]`
        : "void";
      
      const isView = item.stateMutability === "view" || item.stateMutability === "pure";
      const returnType = isView ? `Promise<${outputs}>` : `Promise<ethers.ContractTransactionResponse>`;
      
      functionSignatures.push(`  ${item.name}(${inputs}): ${returnType};`);
    } else if (item.type === "event") {
      const params = item.inputs
        .map((input: any) => `${input.name}: ${solidityToTsType(input.type)}`)
        .join(", ");
      eventSignatures.push(`  ${item.name}: { ${params} };`);
    }
  }
  
  // Generate interface
  lines.push(`export interface ${contractName}Contract {`);
  lines.push(`  // Contract address`);
  lines.push(`  readonly address: string;`);
  lines.push("");
  lines.push(`  // Functions`);
  lines.push(...functionSignatures);
  lines.push(`}`);
  lines.push("");
  
  // Generate events interface
  if (eventSignatures.length > 0) {
    lines.push(`export interface ${contractName}Events {`);
    lines.push(...eventSignatures);
    lines.push(`}`);
    lines.push("");
  }
  
  // Generate factory function
  lines.push(`// Factory function to create typed contract instance`);
  lines.push(`export function get${contractName}Contract(`);
  lines.push(`  address: string,`);
  lines.push(`  signerOrProvider: ethers.Signer | ethers.Provider`);
  lines.push(`): ethers.Contract {`);
  lines.push(`  return new ethers.Contract(address, ${contractName}ABI, signerOrProvider);`);
  lines.push(`}`);
  lines.push("");
  
  // Export ABI constant
  lines.push(`export const ${contractName}ABI = ${JSON.stringify(abi, null, 2)} as const;`);
  
  return lines.join("\n");
}

// Convert Solidity type to TypeScript type
function solidityToTsType(solidityType: string): string {
  // Handle arrays
  if (solidityType.endsWith("[]")) {
    const baseType = solidityType.slice(0, -2);
    return `${solidityToTsType(baseType)}[]`;
  }
  
  // Handle fixed arrays
  const fixedArrayMatch = solidityType.match(/^(.+)\[(\d+)\]$/);
  if (fixedArrayMatch) {
    const baseType = fixedArrayMatch[1];
    return `${solidityToTsType(baseType)}[]`;
  }
  
  // Handle basic types
  if (solidityType.startsWith("uint") || solidityType.startsWith("int")) {
    return "bigint";
  }
  if (solidityType === "bool") {
    return "boolean";
  }
  if (solidityType === "address") {
    return "string";
  }
  if (solidityType === "string") {
    return "string";
  }
  if (solidityType.startsWith("bytes")) {
    return "string";
  }
  if (solidityType === "tuple") {
    return "any"; // Would need more complex handling for structs
  }
  
  return "any";
}

// Parse Solidity source to extract contract names
export function extractContractNames(source: string): string[] {
  const contractRegex = /contract\s+(\w+)/g;
  const names: string[] = [];
  let match;
  
  while ((match = contractRegex.exec(source)) !== null) {
    names.push(match[1]);
  }
  
  return names;
}

// Validate Solidity version pragma
export function extractSolidityVersion(source: string): string | null {
  const pragmaRegex = /pragma\s+solidity\s+([^;]+);/;
  const match = source.match(pragmaRegex);
  
  if (match) {
    return match[1].trim();
  }
  
  return null;
}

// Simple syntax validation (basic checks before compilation)
export function validateSoliditySyntax(source: string): { valid: boolean; errors: string[] } {
  const errors: string[] = [];
  
  // Check for pragma
  if (!source.includes("pragma solidity")) {
    errors.push("Missing pragma solidity statement");
  }
  
  // Check for SPDX license
  if (!source.includes("SPDX-License-Identifier")) {
    errors.push("Missing SPDX-License-Identifier comment");
  }
  
  // Check for balanced braces
  const openBraces = (source.match(/{/g) || []).length;
  const closeBraces = (source.match(/}/g) || []).length;
  if (openBraces !== closeBraces) {
    errors.push(`Unbalanced braces: ${openBraces} opening, ${closeBraces} closing`);
  }
  
  // Check for balanced parentheses
  const openParens = (source.match(/\(/g) || []).length;
  const closeParens = (source.match(/\)/g) || []).length;
  if (openParens !== closeParens) {
    errors.push(`Unbalanced parentheses: ${openParens} opening, ${closeParens} closing`);
  }
  
  return {
    valid: errors.length === 0,
    errors,
  };
}

// Estimate gas for deployment
export function estimateDeploymentGas(bytecode: string): number {
  // Base cost for contract creation
  const baseCost = 21000;
  // Cost per byte of bytecode
  const bytesLength = bytecode.length / 2; // hex string, 2 chars per byte
  const bytesCost = bytesLength * 200; // approximate cost per byte
  
  return baseCost + bytesCost;
}
